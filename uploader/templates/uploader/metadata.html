{# uploader/templates/uploader/metadata.html #}
<div class="govuk-form-group" id="metadata-group">
  <h3 class="govuk-heading-m">Detected metadata</h3>
  <p class="govuk-hint">
    Descriptions are editable. Type inference is based on the first 10 preview rows.
    You can override the inferred type and (for DateTime) pick a format. Click <b>Validate</b> to check the <b>entire file</b>.
  </p>

  <div id="metadata-table-wrap" class="govuk-!-margin-top-2" aria-live="polite">
    <table class="govuk-table" id="metadata-table">
      <caption class="govuk-table__caption govuk-visually-hidden">Column metadata</caption>
      <thead class="govuk-table__head">
        <tr class="govuk-table__row">
          <th scope="col" class="govuk-table__header">Column Name</th>
          <th scope="col" class="govuk-table__header">Description</th>
          <th scope="col" class="govuk-table__header">Data Type</th>
          <th scope="col" class="govuk-table__header">Format (if DateTime)</th>
          <th scope="col" class="govuk-table__header">Coercion Warnings</th>
        </tr>
      </thead>
      <tbody class="govuk-table__body">
        <tr class="govuk-table__row" data-placeholder-row>
          <td class="govuk-table__cell" colspan="5">
            <span class="govuk-hint">Upload a CSV to see column metadata.</span>
          </td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="govuk-button-group govuk-!-margin-top-2">
    <button class="govuk-button" type="button" id="metadata-validate" disabled>
      Validate
    </button>
  </div>
  <textarea class="govuk-visually-hidden" name="metadata_json" id="metadata-json">[]</textarea>
</div>

<style>
  #metadata-table-wrap table.govuk-table code { white-space: pre-wrap; word-break: break-word; }
  #metadata-table-wrap .govuk-table__cell select.govuk-select[disabled] { opacity: .6; }
</style>

<script>
(function () {
  const wrap      = document.getElementById('metadata-table-wrap');
  const jsonField = document.getElementById('metadata-json');
  const validateBtn= document.getElementById('metadata-validate');
  let currentColumnData = null;
  let hasValidated = false;
  let lastFile = null;
  let lastDelimiter = ',';

  const DATE_PATTERNS = [
    { re: /^\d{4}-\d{2}-\d{2}$/, format: 'YYYY-MM-DD' },
    { re: /^\d{2}\/\d{2}\/\d{4}$/, format: 'DD/MM/YYYY' },
    { re: /^\d{2}-\d{2}-\d{4}$/, format: 'DD-MM-YYYY' },
    { re: /^\d{2}\/\d{2}\/\d{2,4}$/, format: 'MM/DD/YYYY' },
    { re: /^\d{4}\/\d{2}\/\d{2}$/, format: 'YYYY/MM/DD' }
  ];
  const DATE_FORMAT_OPTIONS = ['Auto-detect', ...Array.from(new Set(DATE_PATTERNS.map(p=>p.format)))];
  const TYPE_OPTIONS = ['String','Integer','Float','Boolean','DateTime'];

  function isBlank(v){ return String(v ?? '').trim()===''; }
  function isInteger(s){ return /^-?\d+$/.test(s); }
  function isFloat(s){ return /^-?\d*(\.\d+)?([eE][+-]?\d+)?$/.test(s) && s!=='' && !/^[-.]$/.test(s); }
  function detectDateFormat(s){
    for (const p of DATE_PATTERNS) if (p.re.test(s)) return p.format;
    const d=new Date(s); return isNaN(d.valueOf())? null : 'auto-detected';
  }
  function escapeHtml(str){
    return String(str)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;')
      .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function describeType(values){
    const nonBlank = values.filter(v=>!isBlank(v)).map(v=>String(v).trim());
    if (!nonBlank.length) return { type:'String', format:null };
    const allInts   = nonBlank.every(isInteger);
    if (allInts)    return { type:'Integer', format:null };
    const allFloats = nonBlank.every(isFloat);
    if (allFloats)  return { type:'Float', format:null };
    const formats = nonBlank.map(detectDateFormat).filter(Boolean);
    if (formats.length){
      const counts = formats.reduce((m,f)=>((m[f]=(m[f]||0)+1),m),{});
      const top = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      return { type:'DateTime', format:top };
    }
    const allBool = nonBlank.every(v=>/^(true|false|0|1)$/i.test(v));
    if (allBool) return { type:'Boolean', format:null };
    return { type:'String', format:null };
  }

  function countFailuresForType(values, type, formatSelected){
    const nonBlank = values.filter(v=>!isBlank(v)).map(v=>String(v).trim());
    const totalChecked = nonBlank.length;
    if (totalChecked===0) return { failures:0, totalChecked, inferredFormat:null };

    if (type==='Integer'){
      return { failures: nonBlank.filter(v=>!isInteger(v)).length, totalChecked, inferredFormat:null };
    }
    if (type==='Float'){
      return { failures: nonBlank.filter(v=>!isFloat(v)).length, totalChecked, inferredFormat:null };
    }
    if (type==='Boolean'){
      return { failures: nonBlank.filter(v=>!/^(true|false|0|1)$/i.test(v)).length, totalChecked, inferredFormat:null };
    }
    if (type==='DateTime'){
      if (!formatSelected || formatSelected==='Auto-detect'){
        const formats = nonBlank.map(detectDateFormat).filter(Boolean);
        if (!formats.length) return { failures: totalChecked, totalChecked, inferredFormat:null };
        const counts = formats.reduce((m,f)=>((m[f]=(m[f]||0)+1),m),{});
        const top = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
        const fails = nonBlank.filter(v => (detectDateFormat(v)||'') !== top).length;
        return { failures:fails, totalChecked, inferredFormat: top };
      } else {
        const pat = DATE_PATTERNS.find(p=>p.format===formatSelected)?.re;
        if (!pat) return { failures: totalChecked, totalChecked, inferredFormat:null };
        const fails = nonBlank.filter(v => !pat.test(v)).length;
        return { failures:fails, totalChecked, inferredFormat: formatSelected };
      }
    }
    return { failures:0, totalChecked, inferredFormat:null };
  }

  function detectDominantFormat(values){
    const nonBlank = values.filter(v=>!isBlank(v)).map(v=>String(v).trim());
    const formats = nonBlank.map(detectDateFormat).filter(Boolean);
    if (!formats.length) return null;
    const counts = formats.reduce((m,f)=>((m[f]=(m[f]||0)+1),m),{});
    return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
  }

  function makeCsvParser(delimiter) {
    let rows = [];
    let row = [], cur = '', inQuotes = false;

    function feed(text) {
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { cur += '"'; i++; }
            else { inQuotes = false; }
          } else { cur += ch; }
        } else {
          if (ch === '"') inQuotes = true;
          else if (ch === delimiter) { row.push(cur); cur = ''; }
          else if (ch === '\n') { row.push(cur); rows.push(row); row = []; cur = ''; }
          else if (ch === '\r') { /* ignore CR */ }
          else { cur += ch; }
        }
      }
    }
    function flush() {
      if (cur.length || row.length) { row.push(cur); rows.push(row); }
      if (rows.length && rows[rows.length-1].length === 1 && rows[rows.length-1][0] === '') rows.pop();
      const out = rows;
      rows = []; row = []; cur = ''; inQuotes = false;
      return out;
    }
    return { feed, flush };
  }

  async function readAllRows(file, delimiter) {
    const BIG_BYTES = 20 * 1024 * 1024;
    if (file.size <= BIG_BYTES) {
      const text = await file.text();
      const parser = makeCsvParser(delimiter);
      parser.feed(text);
      return parser.flush();
    }
    const reader = file.stream().getReader();
    const decoder = new TextDecoder();
    const parser = makeCsvParser(delimiter);
    let chunk;
    while ((chunk = await reader.read()) && !chunk.done) {
      parser.feed(decoder.decode(chunk.value, { stream: true }));
    }
    parser.feed(decoder.decode());
    return parser.flush();
  }

  const HINT_WAITING = '<span class="govuk-hint">Click “Validate” to check entire file</span>';

  function buildTable(header, bodyRows){
    const cols = header.length;
    const columnData = [];
    for (let i=0;i<cols;i++){
      const name = header[i] || `Column ${i+1}`;
      const sample = bodyRows.map(r=>r[i]??'');
      const { type, format } = describeType(sample);

      columnData.push({
        name,
        sample,
        inferred: type,
        format: type==='DateTime' ? (format || null) : null,
        description:''
      });
    }
    currentColumnData = columnData;
    hasValidated = false;

    let html = '';
    html += '<table class="govuk-table" id="metadata-table">';
    html += '<caption class="govuk-table__caption govuk-visually-hidden">Column metadata</caption>';
    html += '<thead class="govuk-table__head"><tr class="govuk-table__row">';
    html += '<th scope="col" class="govuk-table__header">Column Name</th>';
    html += '<th scope="col" class="govuk-table__header">Description</th>';
    html += '<th scope="col" class="govuk-table__header">Data Type</th>';
    html += '<th scope="col" class="govuk-table__header">Format (if DateTime)</th>';
    html += '<th scope="col" class="govuk-table__header">Coercion Warnings</th>';
    html += '</tr></thead><tbody class="govuk-table__body">';

    columnData.forEach((c, idx)=>{
      const isDate = c.inferred==='DateTime';
      html += '<tr class="govuk-table__row">';
      html += `<td class="govuk-table__cell"><code>${escapeHtml(c.name)}</code></td>`;
      html += `<td class="govuk-table__cell">
                  <input class="govuk-input" type="text" data-col-idx="${idx}" placeholder="Add description…">
                </td>`;
      html += `<td class="govuk-table__cell">
                  <select class="govuk-select" data-col-type="${idx}">
                    ${TYPE_OPTIONS.map(opt => `<option value="${opt}" ${opt===c.inferred?'selected':''}>${opt}</option>`).join('')}
                  </select>
                </td>`;
      html += `<td class="govuk-table__cell">
                  <select class="govuk-select" data-col-format="${idx}" ${isDate?'':'disabled'}>
                    ${DATE_FORMAT_OPTIONS.map(fmt => {
                      const sel = (isDate && ((c.format && fmt===c.format) || (!c.format && fmt==='Auto-detect'))) ? 'selected' : '';
                      return `<option value="${fmt}" ${sel}>${fmt}</option>`;
                    }).join('')}
                  </select>
                </td>`;
      html += `<td class="govuk-table__cell" data-col-warn="${idx}">${HINT_WAITING}</td>`;
      html += '</tr>';
    });
    html += '</tbody></table>';

    wrap.innerHTML = html;

    if (validateBtn) validateBtn.disabled = false;

    wrap.querySelectorAll('input[data-col-idx], select[data-col-type], select[data-col-format]').forEach(el => {
      el.addEventListener('input', handleChange);
      el.addEventListener('change', handleChange);
    });

    saveJson();
  }

  function handleChange(e){
    const t = e.target;
    hasValidated = false;

    if (t.matches('select[data-col-type]')){
      const i = Number(t.getAttribute('data-col-type'));
      const fmtSel = wrap.querySelector(`select[data-col-format="${i}"]`);
      if (t.value==='DateTime'){
        fmtSel.disabled = false;
      } else {
        fmtSel.disabled = true;
      }
    }

    wrap.querySelectorAll('[data-col-warn]').forEach(cell => cell.innerHTML = HINT_WAITING);
    saveJson();
  }

  function totalRowsWarn(failures,total,type,format){
    if (total===0) return '<span class="govuk-hint">No non-empty values in file</span>';
    if (failures>0){
      return `<span class="govuk-error-message">${failures}/${total} values failed to parse as ${escapeHtml(type)}${type==='DateTime'&&format?' ('+escapeHtml(format)+')':''}</span>`;
    }
    return '<span class="govuk-hint">No issues detected</span>';
  }

  async function validateAll(){
    if (!currentColumnData) return;
    let fullRows = null;
    if (lastFile) {
      try {
        fullRows = await readAllRows(lastFile, lastDelimiter || ',');
      } catch (e) {
        console.error('Full-file read failed, falling back to preview sample:', e);
      }
    }

    for (let i=0;i<currentColumnData.length;i++){
      const typeSel = wrap.querySelector(`select[data-col-type="${i}"]`);
      const fmtSel  = wrap.querySelector(`select[data-col-format="${i}"]`);
      const type = typeSel?.value || currentColumnData[i].inferred;
      const fmt  = (fmtSel && !fmtSel.disabled) ? fmtSel.value : null;

      let values;
      if (fullRows && fullRows.length) {
        const rowsOnly = fullRows.slice(1);
        values = rowsOnly.map(r => (r[i] !== undefined ? r[i] : ''));
      } else {
        values = currentColumnData[i].sample;
      }

      const { failures, totalChecked, inferredFormat } = countFailuresForType(values, type, fmt);
      const fmtForMsg = fmt === 'Auto-detect' ? (inferredFormat || null) : fmt;

      const warnCell = wrap.querySelector(`[data-col-warn="${i}"]`);
      if (warnCell) warnCell.innerHTML = totalRowsWarn(failures, totalChecked, type, fmtForMsg);

      if (type==='DateTime' && fmtSel && fmtSel.value==='Auto-detect'){
        fmtSel.title = inferredFormat ? `Auto-detected dominant: ${inferredFormat}` : 'No dominant format detected';
      } else if (fmtSel) {
        fmtSel.title = '';
      }
    }

    hasValidated = true;
    saveJson();
  }

  function saveJson(){
    if (!currentColumnData) { jsonField.value = '[]'; return; }
    const out = currentColumnData.map((c,i)=>{
      const type  = wrap.querySelector(`select[data-col-type="${i}"]`)?.value || c.inferred;
      const fmtEl = wrap.querySelector(`select[data-col-format="${i}"]`);
      const chosenFormat =
        (type==='DateTime' && fmtEl && !fmtEl.disabled)
          ? (fmtEl.value==='Auto-detect' ? (detectDominantFormat(c.sample) || null) : fmtEl.value)
          : null;

      const warningText = hasValidated
        ? (wrap.querySelector(`[data-col-warn="${i}"]`)?.innerText.trim() || '')
        : '';

      return {
        column_name: c.name,
        description: wrap.querySelector(`input[data-col-idx="${i}"]`)?.value || '',
        data_type: type,
        format: chosenFormat,
        coercion_warnings: warningText
      };
    });
    jsonField.value = JSON.stringify(out, null, 2);
  }

  if (validateBtn) validateBtn.addEventListener('click', () => {
    validateBtn.disabled = true;
    Promise.resolve(validateAll).then(fn => fn()).finally(() => {
      validateBtn.disabled = false;
    });
  });

  function renderFromState(state){
    if (!state) return;
    const rows = state.rows || [];
    const header = state.header || (rows[0] || []);
    const maxRows = Math.min(10, rows.length);
    const bodyRows = rows.slice(1, maxRows);
    buildTable(header, bodyRows);
    if (validateBtn) validateBtn.disabled = false;

    lastFile = state.file || null;
    lastDelimiter = state.delimiter || ',';
  }

  window.addEventListener('csv:preview', e => renderFromState(e.detail));

  if (window.CsvPreview && typeof CsvPreview.getState==='function'){
    const state = CsvPreview.getState();
    if (state) renderFromState(state);
  }
})();
</script>